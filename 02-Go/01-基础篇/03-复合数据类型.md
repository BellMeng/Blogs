# 复合数据类型


<extoc></extoc>

## 一、Array

数组是由一个固定长度的特定类型元素组成的序列。数组中的元素可以是零个或多个，数组的长度是数组的组成部分，因此，不同长度或不同类型的数据组成的数组都是不同类型，这就会导致不同长度的数组因为类型不同无法直接赋值。和数组对应的类型是切片(slice)，切片是可以动态增长和收缩的，它是比较灵活的。

数组的基本定义方式如下：

```go
var arr [n]type
```

其中n表示数组的长度，type表示数组存储元素的数据类型。

```go
var a [3]int									//定义长度为3的整型数组，值全部为0
var b [...]int{1, 2, 3}				//定义长度为3的整型数组，元素为1，2，3
var c [...]int{2: 3, 1: 2}		//定义长度为3的整型数组，元素为0，2，3
var d [...]int{1, 2, 4:5, 6}	//定义长度为6的整型数组，元素为1，2，0，0，5，6
```

第一中方式是最基本的，数组的长度明确为3，值为默认值，全部为0；

第二种方式是数组长度未知，自动根据初始化的值来定长度，后面有几个元素长度就是几；

第三种方式是数组长度未知，根据索引来定数组的长度，数组的长度取决于索引的最大值；

第四种方式是数组长度未知，后面元素中包含索引，数组的长度取决于索引的值以及带索引元素的后面的值的个数。

在Go语言中，也支持数组的嵌套，定义方式如下：

```go
var a [2][4]int{[4]int{1, 2, 3, 4},[4]int{5, 6, 7, 8}}
var b [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
```

## 二、Slice

切片是Go语言中一种特殊的数据结构，这种数据结构更便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 `append()` 来实现的，这个函数可以快速且高效地增长切片，也可以通过对切片再次切割，缩小一个切片的大小。因为切片的底层也是在连续的内存块中分配的，所以切片还有获得索引、迭代以及为垃圾回收优化的好处。

切片的初始化和创建方式如下：

```go
slice := make([]int, 5)				// 创建一个整型切片，它的容量和长度都是5
slice := make([]int, 3, 5)		// 创建一个整型切片，它的长度为3，容量为5，并且不允许长度大于容量。
slice := []int{1, 2, 3, 4}		// 通过字面量方式创建一个整型切片，它的长度和容量都是4
```

注意最后一种定义方式与数组的定义方式不同，这里的[]中没有...。

有时候，程序可能需要声明一个nil切片，我们只要在声明的时候不做任何初始化，就可以创建一个nil切片。需要描述一个不存在的切片时，会用到nil切片，比如函数要求返回一个切片，但程序发生异常不能返回时就会用到nil切片。

```go
var slice []int
```

空切片与nil切片不同，**空切片**的底层数组中包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用，
比如，数据库查询返回 0 个查询结果时。

```go
slice := make([]int, 0)			// 使用 make 创建空的整型切片
slice := []int{}						// 使用切片字面量创建空的整型切片
```

我们也可以为切片中的元素单独赋值。

```go
mySlice := []int{10, 20, 30, 40, 50}
mySlice [1] = 25		// 修改索引为1的值
```

可以通过切片来创建新的切片，语法格式如下：

```go
slice[i: j: k]
```

其中i表示从第几个元素开始，j控制切片的长度(j - i)，k控制切片的容量(k - i)，如果没有给定 k，则表示切到底层数组的最尾部。

**切片是会共享底层数据的，切片只能访问到其长度内的元素**。

相对于数组而言，切片还有一个功能就是，可以按需增加切片的容量，Golang 内置的` append()` 函数会处理增加长度时的所有操作细节。在我们对一个切片中增加元素时，它的长度会增加，而容量会根据目前的可用容量来进行变更，若无额外的容量，`append()`会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值，此时切片的长度和容量都将会发生改变。

```go
myNum := []int{10, 20, 30, 40, 50}
newNum := myNum[1:3]
newNum = append(newNum, 60)
```

对于slice有几个有用的内置函数。
●　len获取slice的长度
●　cap获取slice的最大容量
●　append向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice
●　copy函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数

## 三、Map

Go语言中的map与Python中的字典类似，是一个`key: value`的形式，声明的方式如下：

```go
var numbers map[string] int
numbers := make(map[string]int)
numbers["one"] = 1
numbers["two"] = 2
```

- map是无序的，每次打印出来的map都会不一样，并且也不能通过索引来获取value，只能通过key来获取value。
- map的长度是不固定的，与slice相同，是一种引用类型。
- 内置的len函数同样适用于map，返回map中key的数量。

> 其实现原理在后面的学习中将会进行补充修改。












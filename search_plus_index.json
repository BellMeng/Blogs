{"./":{"url":"./","title":"介绍","keywords":"","body":"BellMeng的Blog 本博客主要记录个人的学习情况，仅供参考 如有侵权，请联系2459721102@qq.com "},"SUMMARY.html":{"url":"SUMMARY.html","title":"目录","keywords":"","body":"Summary 介绍 目录 Python 其它 tf_gpu安装 Go 基础篇 GO项目管理 变量的声明及类型 复合数据类型 流程控制 函数 进阶篇 web框架 MySQL MongoDB Redis Docker k8s 基础篇 基本概念 Leetcode 1~100 最长回文子串 Z字形变换 整数反转 字符串转整数 回文数 正则表达式匹配 盛水最多的容器 整数转罗马数字 罗马数字转整数 最长公共前缀 三数之和 PaperRead Medical Transformer-Gated Axial-Attention forMedical Image Segmentation Polarized Self-Attention Towards High-quality Pixel-wise Regression U-Net Transformer Self and Cross Attention forMedical Image Segmentation TransFuse-Fusing Transformers and CNNs forMedical Image Segmentation SAUNet++- An automatic segmentation model of COVID-19 lesion fromCT slices Conformer-Local Features Coupling Global Representations for Visual Recognition Dual-branch combination network-DCN Others 位运算 "},"01-Python/":{"url":"01-Python/","title":"Python","keywords":"","body":""},"01-Python/01-其它/":{"url":"01-Python/01-其它/","title":"其它","keywords":"","body":""},"01-Python/01-其它/01-tf_gpu安装.html":{"url":"01-Python/01-其它/01-tf_gpu安装.html","title":"tf_gpu安装","keywords":"","body":"TensorFlow GPU版本安装 1. 准备 安装好Anaconda、安装好显卡驱动 2. 安装步骤 在Anaconda中创建虚拟环境，指定要安装的tensorflow需要的python版本，并进入环境。 > conda create -n tf-gpu python=3.7 > conda activate tf-gpu 安装tensorflow所依赖的cudatoolkit，cudnn，版本对应关系。 如果依赖库中有对应版本的cudatoolkit和cudnn，那么可以直接使用conda命令安装。 > conda install cudatoolkit=x.x cudnn 如果没有所需的版本，那么就需要到NVIDIA官网下载cuda以及对应的cudnn进行手动安装。 安装tensorflow-gpu，使用conda命令和pip命令安装都可以(建议使用pip命令) > pip install tensorflow-gpu==x.x.x Tips👋： pip命令安装使用国内源会比较快，在命令后面通过-i指定源地址例如:pip install tensorflow-gpu==x.x.x -i https://pypi.douban.com/simple 验证是否安装成功 3. 加速安装小技巧🎉 如果使用默认源安装比较慢，可以切换为清华镜像源 如果清华镜像源总是下载过程中中断，可以尝试连接手机热点来加快下载 切换清华镜像源： 使用conda config --set show_channel_urls yes在家目录下生成.condarc文件 将.condarc文件中的内容替换如下： channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/simpleitk/ - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/win-64/ #如果为linux系统，则将win换成linux即可 - defaults show_channel_urls: true channel_alias: https://mirrors.tuna.tsinghua.edu.cn/anaconda default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/pro - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud "},"02-Go/":{"url":"02-Go/","title":"Go","keywords":"","body":"Go语言 对Go语言的学习主要分为以下三个部分： 基础 进阶 web框架 "},"02-Go/01-基础篇/":{"url":"02-Go/01-基础篇/","title":"基础篇","keywords":"","body":"基础篇 该篇主要从一下几个方面来学习Go语言： Go语言简单介绍 Go代码结构化与项目管理 Go语言中的数据类型 Go语言的基本语法 Go语言中的函数 "},"02-Go/01-基础篇/01-GO项目管理.html":{"url":"02-Go/01-基础篇/01-GO项目管理.html","title":"GO项目管理","keywords":"","body":"GO项目管理 一、包 1.1 包的概念 ​ GO语言中使用包(package)来组织管理代码，包是一种结构化代码的方式，与Java中的类似。在GO语言中，每个.go文件都必须归属一个包，每个.go文件中都可以有init()函数。包在源文件中第一行通过关键字package来进行指定，包名要小写。 package package_name ​ 一个目录下可以有多个.go文件，但是这些文件只能归属于同一个包，main包除外，通常会使用目录名作为包名。同一个包下的不同.go文件可以直接引用变量和函数，所有这些文件中定义的全局变量和函数不能重名。一个项目中必须有一个main包，而且在main包中必须有且只有一个main()函数，main()函数是应用程序运行开始的入口。 1.2 包的初始化及导入 ​ 程序从main包中的main()函数启动，如果main包中导入了其他的包， 那么在编译时会将它们依次导入，有时一个包会被多个包同时导入，那么它只会被导入一次。当在导入某个包时，如果该包还导入了其他包，那么会先将其他包导入进来，再对这些包中的包级常量和变量进行初始化，接着执行init()函数。当所有的包都加载完毕，就会对main包中的包级常量和变量进行初始化，然后执行main包中的init()函数，最后执行main()函数。 ​ GO语言中init()函数通常用于包的初始化，主要有一下特征： init函数是用于执行程序前进行包的初始化的函数，例如初始化包里的变量等。 每个包可以拥有多个init函数。 同一个包中的多个init()函数的执行顺序不定。 不同包的init()函数按照包的导入的依赖关系决定执行顺序。 init()函数不能被其他函数调用，它会在main函数执行前自动被调用。 ​ 在导入包的时候我们使用import关键字，导入操作会使用目录名作为包的路径。import语句一般放在包名定义的下面，格式如下： package main import \"fmt\" // 单个包导入 import ( // 导入多个包 \"fmt\" \"net/http\" ) 另外为了方便使用，还有另外三种特殊的导入包的方式： 包名前面加个点操作：这样导入时，我们可以直接使用里面的函数，不需要写包名。 import ( . \"fmt\" ) 这样我们在调用fmt包中函数时，直接使用Println(\"lalala\")，可以省略掉前缀fmt.。 如果我们将点换成一个变量，我们就可以使用该变量加点，加包中的函数来使用。 import ( f \"fmt\" ) 这样我们在调用fmt包中函数时，使用f.Println(\"lalala\")。 如果我们不想引用包中的函数，但是想调用包里面的init函数，可以直接使用\"_\"操作。 import ( _ \"fmt\" ) 这样就会只调用fmt包中的init函数，而无法使用该包中的函数。 二、GO项目开发与编译 2.1 项目结构 ​ GO的工程项目管理使用目录结构和package名来确定工程结构和构建顺序。要想构建一个项目，必须确保项目目录在GOPATH中，多个项目目录使用分号分隔。在GOPATH目录下一般有三个子目录： src：存放项目和库的源码，GO语言会把go get命令获取到的库文件下载到src目录下对应的文件夹中； pkg：存放编译后生成的文件； bin：存放编译后生成的可执行文件。 ​ 在1.11版本之前，所有的Go项目代码都要保存在GOPATH中，但是在1.11版本之后，GO官方引入了GO Module，使用GO Module管理的项目可以放在GOPATH目录外面。 GO Module 的使用将在后面详细说明 2.2 Go程序编译 ​ 在GO语言中，和编译相关的命令主要有go run、go build、go install这三个命令。 go run只能作用于main包文件，先运行compile命令生成.a文件，然后链接命令生成最终可执行文件并运行，次过程中会产生一些临时文件，在go run命令退出前会删除这些临时文件，最后直接在命令行输出程序执行结果。go run命令在第二次执行的时候，如果发现导入的代码包没有发生变化，则不会再次进行编译这个导入的代码包，而是直接进行链接生成最终可执行文件并运行程序。 go install用于编译并安装指定的代码包以及它们的依赖包，并且将编译后生成的可执行文件放到$GOPATH/bin下，编译后的包文件放到当前工作区pkg目录下。 go build用于编译指定的代码包以及它们的依赖包，如果用来编译非main包的源码，则只做检查性的编译，而不会输出任何结果文件。如果是一个可执行程序的源码，过程与go run大体相同，只是会在当前目录生成一个可执行文件。 2.3 GO Modules包管理 ​ 我们可以通过设置环境变量GO111MODULE来开启或关闭模块支持，它有三个可选值：off、on、auto, 默认为auto。 GO111MODULE=off：无模块支持，GO会从GOPATH和vendor文件夹寻找包 GO111MODULE=on：模块支持，GO会忽略GOPATH和vendor，只根据go.mod下载依赖 GO111MODULE=auto：自动模式，在$GOPATH/src外面且根目录有go.mod文件时，开启模块支持。 它会把下载的依赖存储在$GOPATH/pkg/mod中。 2.3.1 Go Modules中的命令 Go Modules提供的命令如下： 命令 作用 go mod init 在当前文件夹下初始化一个新的module，生成go.mod文件 go mod download 下载go.mod中指明的所有依赖 go mod tidy 整理现有的依赖，增加丢失的module，去掉未使用的module go mod graph 查看现有的依赖结构 go mod edit 编辑go.mod文件 go mod vendor 导出所有的项目依赖到vendor目录 go mod verify 校验某一个模块是否被篡改过 go mod why 查看为什么需要依赖某个模块 2.3.2 Go Modules中的环境变量 Go Modules提供了一些环境变量，通过go env命令可以查看，常用的环境变量如下： $ go env GO111MODULE=\"auto\" GOPROXY=\"https://proxy.golang.org,direct\" GONOPROXY=\"\" GOSUMDB=\"sum.golang.org\" GONOSUMDB=\"\" GOPRIVATE=\"\" ... GO111MODULE：该变量为Go Modules的开关，它的可选值有：auto(为默认值，只要项目中包含了go.mod文件的话，就会启用Go Modules)、on(表示启用Go Modules，推荐设置)、off(表示禁用Go Modules，不推荐) GOPROXY：该变量主要用于设置Go模块的代理，作用是可以直接通过镜像站点来实现快速拉取。但是他的默认值中的https://proxy.golang.org站点，我们在国内是无法直接访问到的，所以我们在使用时需要设置GOPROXY。可参考链接。 $go env -w GOPROXY=https://goproxy.io,direct GOSUMDB：它的值是一个 Go checksum database，用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。它的默认值是sum.golang.org，在国内也是无法访问到的，也可以通过设置GOPROXY来保证它的正常使用。 GONOPROXY/GONOSUMDB/GOPRIVATE：这三个环境变量都是在项目依赖于私有模块，如公司的私有git仓库，又或是github中的私有仓库，都属于私有模块，需要进行设置，否则将会拉取失败。也就是说依赖了由Go模块代理或者是由GOSUMDB指定Go checksum database都无法访问到的模块的场景时，一般建议直接配置GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值。 $ go env -w GOPRIVATE=\"git.example.com,github.com/test/testmodule\" 在这里，我们建议将git的默认协议改成通过ssh来clone代码。 git config --global url.\"ssh://git@xxx.com/\".insteadof \"https:///\" 2.3.3 Go Modules中的go get行为 在项目拉取时，拉取的过程分为三部分：finding(发现)、downloading(下载)和extracting(提取) go get提供的功能： 命令 作用 go get 拉取依赖，会指定性拉取，并不会更新所依赖的其他模块。 go get -u 更新现有依赖，会强制更新它所依赖的其他全部模块，不包括自身。 go get -u -t ./... 更新所有直接依赖和间接依赖的模块版本，包括单元测试中用到的。 go get拉取具体版本： 命令 作用 go get golang.org/x/text@latest 拉取最新的版本，若存在tag，则优先使用。 go get golang.org/x/text@master 拉取 master 分支的最新 commit。 go get golang.org/x/text@v0.3.2 拉取 tag 为 v0.3.2 的 commit。 go get golang.org/x/text@342b2e 拉取 hash 为 342b231 的 commit，最终会被转换为 v0.3.2。 "},"02-Go/01-基础篇/02-变量的声明及类型.html":{"url":"02-Go/01-基础篇/02-变量的声明及类型.html","title":"变量的声明及类型","keywords":"","body":"变量的声明及类型 一、变量的声明 Golang是一种强类型的编程语言，所有的变量必须拥有类型，并且变量只可以存储特定类型的数据。 1.1 变量的定义 在Golang中，定义一个变量需要使用var关键字，当然也有一种简便的写法，不用提前声明，在使用时直接使用:=来进行声明。例如： var vname type //只声明 var vname type = value //声明并初始化 var vname1, vname2 type //同类型多变量声明 var vname1, vname2 type = value1, value2 //同类型多变量声明并初始化 var vname = value //忽略类型声明，直接根据value自动推导数据类型 var vname1, vname2 = value1, value2 vname := value //忽略类型声明，直接根据value自动推导 vname1, vname2 := value1, value2 1.2 匿名变量 标识符为_（下划线）的变量，是系统保留的匿名变量，在赋值后，会被立即释放，称之为匿名变量。其作用是变量占位符，对齐变量赋值结构。通常会在批量赋值时使用。例如，当函数返回多个值时，我们只需要其中某个或某几个时，则不需要的返回值使用_来占位。 1.3 常量的定义 所谓常量，也就是在程序编译阶段就确定下来的值，而程序在运行时则无法改变该值。在Golang中，定义常量需要使用const关键字，并且不能使用:=进行定义。 const PI float32 = 3.1415926 const MaxThread = 10 二、数据类型 go语言中内置基础类型如下： 布尔型：bool 整型： int int64 int32 int16 int8 uint8(byte) uint16 uint32 uint64 uint 浮点型：float32 float64 复数型：complex64 complex128 字符串：string 字符型：rune 错误型：error 2.1 Boolean 在Go语言中，布尔值的类型为bool，值为true或false，默认为false。在赋值的时候只能接受true、false或者逻辑表达式。 var isActivate bool = true var testBool bool = (1 == 2) 2.2 数值类型 数值类型中Golang可以支持整型、浮点型和复数。 整数类型有有符号和无符号两种，Go语言同时支持int和uint。其中byte是uint8的别称，rune是int32的别称。这些类型变量之间不能相互赋值，否则将会导致编译错误。 浮点数类型有float32和float64，默认为float64。 Go语言还支持复数，它的默认类型为complex128（64位实数和64位虚数），另外还有complex64（32位实数和32位虚数）。 var cplex complex128 = 12 + 24i fmt.Println(cplex) // output // (12+24i) 2.3 字符串类型 在Go语言中，字符串采用UTF-8字符集编码，需要使用双引号(\"\")或反引号(``)括起来进行定义，它的类型是string。与Python一样，Go语言中的字符串也是不可变的，也就是说对于一个字符串s:=\"abcd\"，我们不能对单个字符进行修改，如s[0]='b'，这样的操作是不被允许的。 如果确实需要修改可以通过以下方式进行修改： s := \"abcd\" c := []byte(s) c[0] = 'b' s2 := string(c) fmt.Println(s2) 2.4 错误类型 在Go语言中，内置了一个error类型，专门用于处理错误信息，Go语言的package里面还专门有一个errors包来处理错误。 err := errors.New(\"test error\") if err != nil{ fmt.Println(err) } 2.5 iota关键字 iota是Go语言中常量计数器，只能在常量表达式中使用，每出现一个const关键字，iota就初始化为0。 const a = iota //a = 0 const ( //const分组 b = iota //b = 0 c //c = 1 d //d = 2 ) const e = iota //e = 3 如果在const分组中我们不想要连续的值，可以使用匿名变量来进行跳过。 const ( a = iota //a=0 b //b=1 c //c=2 _ //跳过3 _ //跳过4 d //d=5 ) 我们也可以结合位掩码来进行定义： const ( _ = iota KB ByteSize = 1 Go语言设计的一些基本规则： 大写字母开头的变量是可以导出的，即其他包可以读取，是公用变量；小写字母开头的不可导出，是私有变量； 大写字母开头的函数也适用于上述规则。 "},"02-Go/01-基础篇/03-复合数据类型.html":{"url":"02-Go/01-基础篇/03-复合数据类型.html","title":"复合数据类型","keywords":"","body":"复合数据类型 一、Array 数组是由一个固定长度的特定类型元素组成的序列。数组中的元素可以是零个或多个，数组的长度是数组的组成部分，因此，不同长度或不同类型的数据组成的数组都是不同类型，这就会导致不同长度的数组因为类型不同无法直接赋值。和数组对应的类型是切片(slice)，切片是可以动态增长和收缩的，它是比较灵活的。 数组的基本定义方式如下： var arr [n]type 其中n表示数组的长度，type表示数组存储元素的数据类型。 var a [3]int //定义长度为3的整型数组，值全部为0 var b [...]int{1, 2, 3} //定义长度为3的整型数组，元素为1，2，3 var c [...]int{2: 3, 1: 2} //定义长度为3的整型数组，元素为0，2，3 var d [...]int{1, 2, 4:5, 6} //定义长度为6的整型数组，元素为1，2，0，0，5，6 第一中方式是最基本的，数组的长度明确为3，值为默认值，全部为0； 第二种方式是数组长度未知，自动根据初始化的值来定长度，后面有几个元素长度就是几； 第三种方式是数组长度未知，根据索引来定数组的长度，数组的长度取决于索引的最大值； 第四种方式是数组长度未知，后面元素中包含索引，数组的长度取决于索引的值以及带索引元素的后面的值的个数。 在Go语言中，也支持数组的嵌套，定义方式如下： var a [2][4]int{[4]int{1, 2, 3, 4},[4]int{5, 6, 7, 8}} var b [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}} 二、Slice 切片是Go语言中一种特殊的数据结构，这种数据结构更便于使用和管理数据集合。切片是围绕动态数组的概念构建的，可以按需自动增长和缩小。切片的动态增长是通过内置函数 append() 来实现的，这个函数可以快速且高效地增长切片，也可以通过对切片再次切割，缩小一个切片的大小。因为切片的底层也是在连续的内存块中分配的，所以切片还有获得索引、迭代以及为垃圾回收优化的好处。 切片的初始化和创建方式如下： slice := make([]int, 5) // 创建一个整型切片，它的容量和长度都是5 slice := make([]int, 3, 5) // 创建一个整型切片，它的长度为3，容量为5，并且不允许长度大于容量。 slice := []int{1, 2, 3, 4} // 通过字面量方式创建一个整型切片，它的长度和容量都是4 注意最后一种定义方式与数组的定义方式不同，这里的[]中没有...。 有时候，程序可能需要声明一个nil切片，我们只要在声明的时候不做任何初始化，就可以创建一个nil切片。需要描述一个不存在的切片时，会用到nil切片，比如函数要求返回一个切片，但程序发生异常不能返回时就会用到nil切片。 var slice []int 空切片与nil切片不同，空切片的底层数组中包含 0 个元素，也没有分配任何存储空间。想表示空集合时空切片很有用， 比如，数据库查询返回 0 个查询结果时。 slice := make([]int, 0) // 使用 make 创建空的整型切片 slice := []int{} // 使用切片字面量创建空的整型切片 我们也可以为切片中的元素单独赋值。 mySlice := []int{10, 20, 30, 40, 50} mySlice [1] = 25 // 修改索引为1的值 可以通过切片来创建新的切片，语法格式如下： slice[i: j: k] 其中i表示从第几个元素开始，j控制切片的长度(j - i)，k控制切片的容量(k - i)，如果没有给定 k，则表示切到底层数组的最尾部。 切片是会共享底层数据的，切片只能访问到其长度内的元素。 相对于数组而言，切片还有一个功能就是，可以按需增加切片的容量，Golang 内置的append() 函数会处理增加长度时的所有操作细节。在我们对一个切片中增加元素时，它的长度会增加，而容量会根据目前的可用容量来进行变更，若无额外的容量，append()会创建一个新的底层数组，将被引用的现有的值复制到新数组里，再追加新的值，此时切片的长度和容量都将会发生改变。 myNum := []int{10, 20, 30, 40, 50} newNum := myNum[1:3] newNum = append(newNum, 60) 对于slice有几个有用的内置函数。 ●　len获取slice的长度 ●　cap获取slice的最大容量 ●　append向slice里面追加一个或者多个元素，然后返回一个和slice一样类型的slice ●　copy函数copy从源slice的src中复制元素到目标dst，并且返回复制的元素的个数 三、Map Go语言中的map与Python中的字典类似，是一个key: value的形式，声明的方式如下： var numbers map[string] int numbers := make(map[string]int) numbers[\"one\"] = 1 numbers[\"two\"] = 2 map是无序的，每次打印出来的map都会不一样，并且也不能通过索引来获取value，只能通过key来获取value。 map的长度是不固定的，与slice相同，是一种引用类型。 内置的len函数同样适用于map，返回map中key的数量。 其实现原理在后面的学习中将会进行补充修改。 "},"02-Go/01-基础篇/04-流程控制.html":{"url":"02-Go/01-基础篇/04-流程控制.html","title":"流程控制","keywords":"","body":"流程控制 一、Switch switch有两种形式：表达式型switch和类型型switch，在表达式型switch中，包含与switch表达式的值进行比较的表达式；在类型型switch中，包含与switch表达式的类型进行比较的类型。switch表达式在switch语句中只运行一次。 switch语句的语法格式如下： switch expr { case val1: ... case val2: ... default: ... } 在这里，expr可以有三种表示方式，第一种形式是执行一个简单语句，该语句返回一个值，然后case中的值与该值进行比较。第二中方式是expr为空，也就相当于ture，在case中直接写条件表达式，相当于这些表达式的结果与true进行比较。第三种方式是expr为一个初始化语句，这与第二中方式相同，只是多了个初始化语句。 在case代码块中我们可以通过fallthrough关键词无条件的进入下一个case的代码块中，不需要判断条件是否满足，该关键词也可以用于default的代码块中。 func main() { a := 2 switch { case a = 5: fmt.Println(\"a >= 5\") default: fmt.Println(a) } } // output a = 5 类型型switch判断的是类型而不是值，它由一个特殊的switch表达式标记，该表达式使用类断言的形式来进行动态类型判断，如下： var t interface{} t = functionOfSomeType() // 这里的functionOfSomeType()是一个带返回值的函数，t用来接收这个返回值 switch t.(type) { default: fmt.Printf(\"unexpected type %T\\n\", t) // %T prints whatever type t has case bool: fmt.Printf(\"boolean %t\\n\", t) // t has type bool case int: fmt.Printf(\"integer %d\\n\", t) // t has type int case *bool: fmt.Printf(\"pointer to boolean %t\\n\", *t) // t has type *bool case *int: fmt.Printf(\"pointer to integer %d\\n\", *t) // t has type *int } 二、select语句 select是Go语言中的一个控制结构，语法类似于switch语句，主要用于处理异步通道操作，所有的情况都会涉及通信操作，因此select会监听分支语句中通道的读写操作。当分支中的通道读写操作为非阻塞状态时，将会出发相应的动作。select语句会选择一组可以发送或接收操作中的一个分支继续执行。select没有条件表达式，一直在等待case进入可运行状态。 select中的case语句必须是对通道的操作。 select中的default子句如果有，它必须是可以运行的。 如果有多个分支，select会伪随机公平的选出一个执行，其他分支不会执行 如果没有可以 运行的分支，但是有default语句，则会执行default中的语句 如果没有可以运行的分支，且没有default语句，select将会阻塞，直到某个分支可以运行。 后面学习到channel会给出相应示例。 三、循环结构 3.1 for语句 for语句格式如下： for 初始化语句; 条件语句; 修饰语句{ } 当然，这里面的任何一部分都是可以省略的。 // 也可以什么都没有 for { }//或者如下方式 for ;;{ } 也就是说如果没有条件语句的话，就相当于一直为true，我们可以再for代码块中写判断条件来推出for循环。 3.2 for-range结构 for-range结构是Go语言中特有的一种迭代结构，它可以迭代任何一个集合，包括数组(array)和字典(map)，同时可以获得每次迭代所对应的索引值。一般的格式如下： for idx, val:= range coll {} 如果值需要range中的索引值，则只写idx就可以。 for idx := range coll {} 如果我们只想要里面的值，可以用如下方式实现： for _, val := range coll {} val为集合中对应索引的值的副本，我们如果对其进行修改，将不会影响原集合中的元素值。如果val为指针类型，则会产生指针的副本，但是用其对集合中的元素修改是有效的。 四、if语句 if语句由bool表达式后紧跟一个或多个语句组成，这里的布尔表达式不需要使用括号。 if语句后也接受初始化语句，用于设置局部变量，该语句将会写再布尔表达式之前。 if x:=f(); x 五、break、continue、goto语句 5.1 break语句 break语句的作用是跳过整个代码块，它可以出现再switch、select、for的代码块中。 5.2 continue语句 continue语句用于循环中，它可以忽略剩余的循环体而直接进入下一次循环的过程中，但是同样也要满足循环的判断条件才能继续执行下一次循环 。 5.3 goto语句 在了解goto语句之前必须要知道标识符（标签），它是某一行第一个以冒号结尾的单词，对大小写敏感的，一般建议全部使用大写字母，例如： ERROR: log.Panic(\"error encountered\") break、continue、goto语句均可以后接标签。 例如： break语句 OuterLoop: for i:= 0; i 也就是说我们可以通过break加标签的方式指定跳出哪个循环 continue也是同样的道理。 goto语句是跳转到具有相同函数内相应标签的语句。 goto ERROR 虽然支持这些操作，但是在Go语言中不鼓励使用标签和goto语句。 "},"02-Go/01-基础篇/05-函数.html":{"url":"02-Go/01-基础篇/05-函数.html","title":"函数","keywords":"","body":"函数 一、Go语言中的函数 在GO语言中，函数的基本组成如下： func 函数名(参数列表)(返回值列表){ //函数体 return } 例如我们定义一个简单的add函数： func add(a int, b int) int { return a + b } func add(a int, b int) (c int){ //返回值中参数中指定变量的名字，在函数体中可以直接使用 c = a + b return } 在GO语言中，函数的参数不支持默认值，函数调用传入的参数必须按照参数声明的顺序。如果函数声明了返回值，则函数体中的语句列表必须以终止语句结束。GO语言中的函数也不支持函数重载(function overloading)； tips: 函数重载：指的是可以编写多个同名的函数，只要它们拥有不同的形参或者不同的返回值。 "},"02-Go/02-进阶篇/":{"url":"02-Go/02-进阶篇/","title":"进阶篇","keywords":"","body":"进阶篇 该篇主要从以下几个方面来学习Go语言： Go语言中的面向对象 Go语言中的并发 Go语言中的系统标准库 Go语言中的网络编程 Go语言中的数据格式与存储 "},"02-Go/03-web框架/":{"url":"02-Go/03-web框架/","title":"web框架","keywords":"","body":"Web框架 该部分主要介绍Go语言的Web框架： Gin ... "},"03-MySQL/":{"url":"03-MySQL/","title":"MySQL","keywords":"","body":""},"04-MongoDB/":{"url":"04-MongoDB/","title":"MongoDB","keywords":"","body":""},"05-Redis/":{"url":"05-Redis/","title":"Redis","keywords":"","body":""},"06-Docker/":{"url":"06-Docker/","title":"Docker","keywords":"","body":""},"07-k8s/":{"url":"07-k8s/","title":"k8s","keywords":"","body":""},"07-k8s/01-基础篇/":{"url":"07-k8s/01-基础篇/","title":"基础篇","keywords":"","body":""},"07-k8s/01-基础篇/01-基本概念.html":{"url":"07-k8s/01-基础篇/01-基本概念.html","title":"基本概念","keywords":"","body":"k8s简介和基本概念 一、k8s是什么？🧐 k8s(Kubernetes简称)是一种可自动实施Linux容器操作的开源平台。 k8s实现了 服务发现和负载均衡 存储编排 自动部署和回滚 自动完成装箱计算 自我修复 密钥与配置管理 它可以帮我们轻松的管理集群，并且这些集群可以跨公有云、私有云或混合云部署主机。 二、k8s中的基本概念 Kubernetes中的大部分概念如Node、Pod、ReplicationController、Service等都可以看作一种“资源对象”，几乎所有的资源对象都可以通过Kubernetes提供的kubectl工具（或者API编程调用）执行增、删、改、查等操作并将其保存在etcd中持久化存储。从这个角度来看，Kubernetes其实是一个高度自动化的资源控制系统，它通过跟踪对比etcd库里保存的“资源期望状态”与当前环境中的“实际资源状态”的差异来实现自动控制和自动纠错的高级功能。 2.1 Master Master表示的是集群的控制节点，每个Kubernetes集群中都需要一个Master节点来负责整个集群的管理和控制，基本上Kubernetes所有的控制命令都是发给Master节点，然后由其负责具体的执行。它上面运行着如下几个关键进程： Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，Kubernetes中资源对象增删改查的唯一入口，集群控制的入口； Kubernetes Controller Manager（kube-controller-manager）：Kubernetes所有资源的自动化控制中心； Kubernetes Scheduler（kube-scheduler）：负责资源调度的进程。 在Master节点上通常会启动etcd Server进程，用于保存Kubernetes中所有的资源对象。 如果Master节点宕机或不可用，所有的命令将都会失效。 2.2 Node Kubernetes集群中除Master节点之外的机器都称为Node，Node节点是集群中工作负载节点，每个Node都会被分配一些工作负载，当某个Node宕机时，在该Node上的工作负载会被分配到其他的Node上去。每个Node节点都会运行着以下几个关键进程： kubelet：负责Pod对应容器的创建、启停等任务，同时与Master节点密切协作，实现集群管理功能，会定时向Master节点汇报自身的情况； kube-proxy：实现Kubernetes Service的通信与负载均衡的重要组件； Docker Engine：Docker容器引擎，负责本机的容器创建和管理工作。 2.3 Pod Pod是Kubernetes集群中最重要和最基本的概念，每一个Pod都有一个根容器Pause容器。除了Pause容器之外，每个Pod还包含一个或多个紧密相关的用户业务容器。 Pod使用该组成结构的意义： 更容易的判断Pod的状态，使用Pause容器的状态来判断整个容器组的的状态； 多个业务容器共享Pause容器的IP，共享Pause容器挂接的Volume，简化业务容器间的通信问题，解决了业务容器间的文件共享问题。 Pod分为两种：普通Pod和静态Pod，静态Pod不会存放在Kubernetes的etcd存储里，而是存放在某个具体的Node上的一个具体文件中，并且只在此Node上运行。普通的Pod将会被自动启停和调度。 2.4 Label 一个Label就是一个key=value的键值对，其中key和value由用户指定，Label可以附加到任何资源对象上。 当我们给某个资源对象定义了一个Label之后，可以通过Label Selector来查询或筛选拥有某些Label的资源对象。 2.5 Replication Controller(RC) RC用于控制应在集群某处运行的完全相同的容器集副本数量。RC的定义主要包含以下几个部分： Pod期望的副本数量； 用于筛选目标Pod的Label Selector； 当Pod的数量小于期望数量时，用于创建Pod的Pod的模板。 在运行时，我们也可以修改RC副本的数量，实现Pod的动态缩放功能。 注意： 删除RC并不会影响通过该RC创建的Pod，为了删除所有Pod需要将RC中的replicas设置为0，然后更新该RC。 在这里还有一个ReplicaSet的概念，它主要用于保证给定数量的、完全相同的Pod的可用性。 2.6 Deployment 为了更好的解决Pod的编排问题引入了Deployment，Deployment在内部使用Replica Set来实现。 Deployment的典型应用场景： 创建Deployment以将ReplicaSet上线。ReplicaSet在后台创建Pod。检查ReplicaSet的上线状态，查看其是否成功。 通过更新Deployment的PodTemplateSpec，声明Pod的新状态。新的ReplicaSet会被创建，Deployment以受控速率将Pod从旧ReplicaSet迁移到新ReplicaSet。每个新的ReplicaSet都会更新Deployment的修订版本。 如果Deployment的当前状态不稳定，回滚到较早的Deployment版本。每次回滚都会更新Deployment的修订版本。 扩大Deployment规模以承担更多负载。 暂停Deployment以应用对PodTemplateSpec所作的多项修改，然后恢复其执行以启动新的线上版本。 使用Deployment状态来判定上线过程是否出现停滞。 清理较旧的不再需要的ReplicaSet。 2.7 Horizontal Pod Autoscaler(HPA) Pod横向自动扩容，它可以基于负载变化情况自动扩缩ReplicationController、Deployment、ReplicaSet和StatefulSet中的Pod数量。 HPA可以有以下两种方式作为Pod负载的度量指标： CPU利用率 应用程序自定义的度量指标，比如TPS、QPS。 2.8 Service 服务，它是逻辑上的一组Pod，一种可以访问它们的策略，通常被称为微服务。 2.9 Volume Volume是Pod中能够被多个容器访问的共享目录。Kubernetes中的Volume定义在Pod上，然后被一个Pod里的多个容器挂载到具体的文件目录下，；其次，Kubernetes中的Volume的声明周期与Pod相同，与容器的生命周期不相关，当容器终止或者重启时，数据不丢失。 Kubernetes中提供了非常丰富的Volume类型，具体如下： emptyDir：一个emptyDir Volume是在Pod分配到Node时创建的，它是由Kubernetes自动分配的一个目录。当Pod从Node上移除时，emptyDir中的数据也会被永久删除。emptyDir的一些用途如下： 临时空间，应用程序运行时所需的临时目录，且无需永久保留； 长时间任务的中间过程Checkpoint的临时保存目录； 一个容器需要从另一个容器中获取数据的目录(多容器共享目录)。 hostPath：为在Pod上挂载宿主机上的文件或目录，通常可以用于以下几个方面： 容器应用程序生成的日志文件需要永久保存时，可以使用宿主机的高速文件系统进行存储； 需要访问宿主机上Docker引擎内部数据结构的容器应用时，可以通过定义hostPath为宿主机/var/lib/docker目录，使容器内部应用可以直接访问Docker的文件系统。 gcePersistentDisk：表示使用谷歌公有云提供的永久磁盘（Persistent Disk，PD）存放Volume的数据。这上面的数据会永久保存，当Pod被删除时，PD只是被卸载(unmount)。 awsElasticBlockStore：与GCE相同，是由aws提供的。 NFS：使用NFS网络文件系统提供共享目录存储数据时，需要在系统中部署一个NFS Server。 其他类型的Volume： iscsi：使用iSCSI存储设备上的目录挂载到Pod中。 flocker：使用Flocker来管理存储卷。 glusterfs：使用开源GlusterFS网络文件系统的目录挂载到Pod中。 rbd：使用Linux块设备共享存储（Rados Block Device）挂载到Pod中。 gitRepo：通过挂载一个空目录，并从GIT库clone一个git repository以供Pod使用。 secret：一个secret volume用于为Pod提供加密的信息，你可以将定义在Kubernetes中的secret直接挂载为文件让Pod访问。secret volume是通过tmfs（内存文件系统）实现的，所以这种类型的volume总是不会持久化的。 2.10 Persistent Volume 相当于网络存储中对应的一块存储。 2.11 Namespace 在很多情况下用于实现多租户的资源隔离，形成逻辑上的分组，便于不同分组在共享使用整个集群资源的同时还能被分别管理。 2.12 Annotation Annotation与Label相似，同样使用key/value键值对的形式进行定义。Annotation是可以用户任意定义，便于外部工具进行查找。 一般会使用Annotation来记录下面列出的相关信息： build信息、release信息、Docker镜像信息等，例如时间戳、release id号、PR号、镜像hash值、docker registry地址等。 日志库、监控库、分析库等资源库的地址信息。 程序调试工具信息，例如工具名称、版本号等。 团队的联系信息，例如电话号码、负责人名称、网址等。 "},"08-Leetcode/":{"url":"08-Leetcode/","title":"Leetcode","keywords":"","body":""},"08-Leetcode/01-1~100/":{"url":"08-Leetcode/01-1~100/","title":"1~100","keywords":"","body":""},"08-Leetcode/01-1~100/005-最长回文子串.html":{"url":"08-Leetcode/01-1~100/005-最长回文子串.html","title":"最长回文子串","keywords":"","body":"最长回文子串 一、题目 最长回文子串 二、题解 动态规划： func longestPalindrome(s string) string { lenS := len(s) dpArr := make([][]bool, lenS) for i := 0; i = lenS{ break } if s[i] != s[j] { dpArr[i][j] = false }else { if j - i maxLen{ maxLen = j-i +1 begin = i } } } return s[begin: begin+maxLen] } "},"08-Leetcode/01-1~100/006-Z字形变换.html":{"url":"08-Leetcode/01-1~100/006-Z字形变换.html","title":"Z字形变换","keywords":"","body":"Z字形变换 一、题目 Z字形变换 二、题解 func convert(s string, numRows int) string { zArr := make([]string, numRows) lenS := len(s) if numRows == 1{ return s } row := 0 down := true for i:= 0; i "},"08-Leetcode/01-1~100/007-整数反转.html":{"url":"08-Leetcode/01-1~100/007-整数反转.html","title":"整数反转","keywords":"","body":"整数反转 一、题目 整数反转 二、题解 func reverse(x int) int { res := 0 for x != 0 { n := x % 10 x /= 10 tmp:= res*10 + n if tmp math.MaxInt32{ return 0 } res = tmp } return res } "},"08-Leetcode/01-1~100/008-字符串转整数.html":{"url":"08-Leetcode/01-1~100/008-字符串转整数.html","title":"字符串转整数","keywords":"","body":"字符串转整数atoi 一、题目 字符串转整数atoi 二、题解 func myAtoi(s string) int { res := 0 lenS := len(s) fu := false appearNum := false for idx, v := range s { if (v == '-' || v == '+') && idx+1 math.MaxInt32 { return math.MaxInt32 } else { res = tmp } }else if v==' ' && !appearNum{ continue }else { break } } if fu { return -res } else { return res } } "},"08-Leetcode/01-1~100/009-回文数.html":{"url":"08-Leetcode/01-1~100/009-回文数.html","title":"回文数","keywords":"","body":"回文数 一、题目 回文数 二、题解 func isPalindrome(x int) bool { if x "},"08-Leetcode/01-1~100/010-正则表达式匹配.html":{"url":"08-Leetcode/01-1~100/010-正则表达式匹配.html","title":"正则表达式匹配","keywords":"","body":"正则表达式匹配 一、题目 正则表达式匹配 二、题解 "},"08-Leetcode/01-1~100/011-盛水最多的容器.html":{"url":"08-Leetcode/01-1~100/011-盛水最多的容器.html","title":"盛水最多的容器","keywords":"","body":"盛水最多的容器 一、题目 盛水最多的容器) 二、题解 func min(v1 int, v2 int) int { if v1 maxA { maxA = tmpA } if height[l] > height[r]{ r-- }else{ l++ } } return maxA } "},"08-Leetcode/01-1~100/012-整数转罗马数字.html":{"url":"08-Leetcode/01-1~100/012-整数转罗马数字.html","title":"整数转罗马数字","keywords":"","body":"整数转罗马数字 一、题目 整数转罗马数字 二、题解 var valueSymbols = []struct { value int symbol string }{s {1000, \"M\"}, {900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"}, {90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"}, {9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"}, } func intToRoman(num int) string { romanNum := []byte{} for _, vs := range valueSymbols{ for num >= vs.value { num -= vs.value romanNum = append(romanNum, vs.symbol...) } if num == 0 { break } } return string(romanNum) } "},"08-Leetcode/01-1~100/013-罗马数字转整数.html":{"url":"08-Leetcode/01-1~100/013-罗马数字转整数.html","title":"罗马数字转整数","keywords":"","body":"罗马数字转整数 一、题目 罗马数字转整数 二、题解 var symbolValues = map[byte]int{ 'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000, } func romanToInt(s string) int { var result int = 0 lengthS := len(s) for i := 0; i "},"08-Leetcode/01-1~100/014-最长公共前缀.html":{"url":"08-Leetcode/01-1~100/014-最长公共前缀.html","title":"最长公共前缀","keywords":"","body":"最长公共前缀 一、题目 最长公共前缀 二、题解 func longestCommonPrefix(strs []string) string { lenStrs := len(strs) if lenStrs == 0 { return \"\" } var prefix string for i:=0; i "},"08-Leetcode/01-1~100/015-三数之和.html":{"url":"08-Leetcode/01-1~100/015-三数之和.html","title":"三数之和","keywords":"","body":"三数之和 一、题目 三数之和 二、题解 func threeSum(nums []int)[][]int{ sort.Ints(nums) res := [][]int{} for i:=0; i 0{ break } if i >0 && n1==nums[i-1]{ continue } l:=i+1 r:=len(nums)-1 for ;l 排序加双指针 "},"09-PaperRead/":{"url":"09-PaperRead/","title":"PaperRead","keywords":"","body":""},"09-PaperRead/01-Medical Transformer-Gated Axial-Attention forMedical Image Segmentation.html":{"url":"09-PaperRead/01-Medical Transformer-Gated Axial-Attention forMedical Image Segmentation.html","title":"Medical Transformer-Gated Axial-Attention forMedical Image Segmentation","keywords":"","body":"Medical Transformer: Gated Axial-Attention forMedical Image Segmentation Code在卷积网络和三种不同数据集上的完全关注体系结构上成功地提高了医学图像分割任务的性能。 一、摘要 ​ 在过去的十年中，深度卷积神经网络被广泛应用于医学图像分割，并取得了良好的效果。但是卷积结构中存在固有的感应偏差，它们缺乏对图像中长程相关性的理解。最近提出的基于transformer的体系结构利用自我注意机制对长范围依赖项进行编码，并学习具有高度表达能力的表示。这促使我们探索基于transformer的解决方案，并研究将基于变压器的网络体系结构用于医学图像分割任务的可行性。但是对于计算机视觉方向提出的基于Transformer的网络结构大多数都需要大规模的数据集，但是目前医学图像数据样本的数量相对较低，因此很难训练出有效的基于Transformer的模型。 ​ 为了解决上述问题，本文提出了一个门控轴向注意力(Gated axial-attention)模型。该模型通过在Self-Attention模块中引入额外的控制机制来扩展现有的体系结构。此外，为了在医学图像上有效的训练模型，我们提出了一种局部-全局训练策略(LoGo)，进一步提高了性能，我们对整个图像和各个patch进行操作，分别学习局部和全局的特征。 本文内容： 1) 提出了一种选通位置敏感轴向注意机制，即使在较小的数据集上也能很好地工作。 2) 引入了基于Transformer的局部-全局（LoGo）训练方法，并证明该方法是有效的。 3) 提出了Medical Transformer（MedT），该Transformer基于上述两个专门为医学图像分割提出的概念。 4) 三种不同数据集上成功地提高了医学图像分割任务的性能。 二、内容 2.1 Self-Attention概述 Self-Attention是从NLP中借鉴过来的思想，因此仍然保留了Query、Key和Value等名称，它的基本结构如下： 它从上到下分为三个分支，分别为query、key和value。计算时通常分为三步： 第一步是将query和每个key进行相似度计算得到权重，常用的相似度函数有点积，拼接和感知机等。 第二步一般是用一个softmax函数对这些权重进行一些归一化； 第三步将权重和相应的key-value进行加权求和得到最后的attention map。 Self-Attention相关博客： https://blog.csdn.net/qq_37935516/article/details/104123018 与卷积不同，Self-Attention可以从feature map中获取非局部的信息， 2.2 Axial-Attention 为了克服计算相似性时的计算复杂度，我们将一个self-attention分解为两个self-attention子模块，第一个self-attention子模块在高度方向上进行self-attention，第二个self-attention子模块在宽度方向上进行self-attention，这被称为Axial-Attention。为了通过Self-attention计算相似性时添加位置偏差，我们添加了偏置项，使相似性对位置信息敏感，这个偏置项通常被称为相对位置编码。这些位置编码信息通常是可以被训练的，并且已经证明了其具有编码图像空间结构的能力。 对于任何给定的特征图x，带有位置编码和宽度轴向self-atttention的自注意力机制可以用以下方式表示： 2.3 Gate Axial-Attention 为了解决小规模数据集，位置偏差难学习的问题，我们提出了一种能够控制位置偏差对非局部上下文编码的影响的修正双轴注意块。 将我们提出的修改放到宽度轴向注意力中可以用以下方式表示： 其中GQ, GK, GV1, GV2都是可学习的参数，它们创建了一个门控机制，控制学习到的相对位置编码对编码非局部上下文的影响。通常，如果准确地学习了相对位置编码，则与未准确学习的编码相比，选通机制将为其分配较高的权重。 2.4 Local-Global Training 很显然，将图片切分成patch在transformer中训练的速度更快，但是在各个patch上进行单独的训练不能够完成医学图像分割的任务，它限制了网络学习各个位置关系的相关性。为了提高对图像的整体理解，我们提出在模型中使用两个分支，一个是处理图像原始分辨率的全局分支，另一个是处理图像patch的局部分支。 "},"09-PaperRead/02-Polarized Self-Attention Towards High-quality Pixel-wise Regression.html":{"url":"09-PaperRead/02-Polarized Self-Attention Towards High-quality Pixel-wise Regression.html","title":"Polarized Self-Attention Towards High-quality Pixel-wise Regression","keywords":"","body":"Polarized Self-Attention: Towards High-quality Pixel-wise Regression Code 1. 摘要 像素回归可能是细粒度计算机视觉任务中最常见的问题，如估计匹配关键点热图和分割掩膜。这些回归问题非常具有挑战性，特别是因为它们需要在较低的计算开销下，对高分辨率输入/输出的长程依赖性进行建模，以估计高度非线性的像素语义。虽然深卷积神经网络（DCNN）中的注意机制已成为增强长程依赖性、元素特定注意（如非局部块）的常用机制，这是一个高度复杂且对噪音敏感的学习过程，大多数简化的注意力混合体都试图在多种任务之间达成最佳折衷，我们提出了极化自我注意（PSA）模块，该模块结合了两个关键设计，以实现高质量像素回归： (1) 极化滤波：在通道和空间注意力计算中保持高内部分辨率，同时完全折叠输入沿对应维度的张量。 (2) 增强：组合非线性直接拟合典型细粒度回归的输出分布，例如二维高斯分布（关键点热图）或二维二项分布（二进制分割掩码）。 2. 方法 在研究界和工业界，计算机视觉的任务从粗粒度到细粒度的转变趋势已经取得了进步。与粗粒度任务相比，像素级的感知越来越吸引人，如自动驾驶，增强现实，医疗图像处理和公共监视。 2.1 Self-Attention for Pixel-wise Regression 用于像素回归的DCNN沿两个维度学习特征的加权组合：(1)通道特定加权用以估计具体类别的输出分数; (2)空间特定权重，用于检测具有相同语义的像素。应用于DCNN的自注意机制有望进一步突出以上两个目标。 如何实现像素回归的通道特定权重和空间特定权重： 2.1.1 Internal Attention Resolution 回想一下，大多数像素级回归DCNN使用相同的主干网络，如：ResNet，作为分类和坐标回归任务。为了鲁棒性和计算效率，这些backbone产生低分辨率的特征图。像素回归无法避免这种分辨率损失，特别是因为对象边缘和身体部位的高非线性很难在低分辨率特征中编码。 在像素回归中使用这些backbone，自注意块有望在注意力计算中保持高分辨率的语义。 2.1.2 Output Distributions/Non-linearity 在逐像素回归的DCNN中，输出通常编码为三维张量，通过线性变换（如卷积）直接拟合分布的非线性可能会减轻DCNN的学习负担。然而，现有的Internal Attention Block都不包含这样的非线性函数组合。 2.2 Polarized Self-Attention (PSA) Block ​ 为了解决上述的问题，我们提出在注意力计算中进行极化滤波。一个Self-Attention块在输入张量X上进行操作，用来突出或抑制特征，这非常类似于滤光的光学透镜。在摄影中，在不同的方向上总是有随机的光，产生眩光/反射。极性化滤波，通过只允许光通过与横向正交的方向，可以潜在地改善照片的对比度。由于总强度的损失，滤波后的光通常具有较小的动态范围，因此需要额外的增强，例如：通过HDR来恢复原始场景的细节。 ​ 我们借用摄影的关键因素，提出了偏振自注意机制： ​ (1) Filtering: 在一个方向上完全折叠特征，同时在其正交方向上保留高分辨率特征。 ​ (2) HDR: 在瓶颈张量(注意力块中最小特征)中进行Softmax归一化，然后使用类高斯函数进行色调映射，从而增加注意的动态范围。 与其他自注意机制相比， 内部分辨率和复杂性：与顶部配置下的现有注意块相比，PSA在通道和空间维度上保持了最高的注意分辨率。 除此之外，在我们的channel-only attention中，softmax重新加权与SE块融合，利用softmax作为瓶颈处的非线性激活函数。我们的设计在相当于GC块计算复杂度的情况下进行了更高的分辨率压缩和激发。 3. 未来工作 ​ 我们提出了极化自我注意（PSA）块，以实现高质量的逐像素回归。与其他DCNN相比， PSA 显着提升了两个关键设计 (1) 在极化的仅通道和仅空间注意分支中保持高内部分辨率，以及 (2) 结合了充分利用高分辨率信息的非线性组合保存在 PSA 分支中。 PSA 可以潜在地使任何具有像素回归的计算机视觉任务受益。 ​ 目前尚不清楚 PSA 如何最有利于嵌入复杂 DCNN 头中的分类和位移回归的像素回归，例如实例分割、无锚对象检测和全景分割任务中的那些。 据我们所知，大多数现有的带有自注意力块的工作只在骨干网络中插入块。 我们未来的工作是探索在 DCNN 头中使用 PSA。 "},"09-PaperRead/03-U-Net Transformer Self and Cross Attention forMedical Image Segmentation.html":{"url":"09-PaperRead/03-U-Net Transformer Self and Cross Attention forMedical Image Segmentation.html","title":"U-Net Transformer Self and Cross Attention forMedical Image Segmentation","keywords":"","body":"U-Net Transformer: Self and Cross Attention forMedical Image Segmentation Code 未开源 一、摘要 ​ 对于复杂和低对比度的解剖结构，医学图像分割依然是一个特别具有挑战性的问题。本文中，我们提出了U-Transformer网络结构，它将用于医学图像分割的U形结构和Transformer中的自注意力机制和交叉注意力机制结合。U-Transformer克服了U-Net无法对长程上下文交互和空间依赖建模的问题，这对于在具有挑战性的上下文中进行精确分割至关重要。为此，注意力机制包含在两个主要层面：自注意力模块利用编码器特征之间的全局交互，跳跃连接中的交叉注意力通过过滤到非语义特征在U-Net解码器中实现了良好的空间恢复。在两个腹部CT图像数据集上的实验表明，与U-Net和局部注意U-Net相比，U-Transformer带来了较大的性能增益。我们还强调了使用自我和交叉注意的重要性，以及U-Transformer带来的良好的可解释性特性。 二、模型结构 ​ U-Transformer通过使用两种类型的注意模块：多头自我注意（MHSA）和多头交叉注意（MHCA），对长范围的上下文交互和空间依赖性进行建模。 ​ 这两个模块的设计都是基于输入在第一种情况下的自我关注或在第二种情况下对更高层次特征的关注来表达输入的新表示。 2.1 MHSA ​ MHSA模块用于从图像中提取远程结构信息。为此，它由《Attention is all you need》中所述的位于U形网络底部的多头自我注意功能组成，MHSA 的主要目标是将最高特征图中的每个元素相互连接，从而访问包含所有输入图像的感受野。Self-Attention的公式如下： ​ 为了考虑绝对上下文信息，在输入特征中添加了位置编码。它特别适用于医学图像分割，其中不同的解剖结构遵循固定的空间位置。因此，可以利用位置编码捕获MHSA中器官之间的绝对和相对位置。 2.2 MHCA 注意力机制还可用于提高U-Net中解码器的效率，特别是可以增强通过跳跃连接传递过来的低层的特征图。事实上，如果这些跳过连接确保保留高分辨率信息，它们就缺乏可以在更深层次的网络中找到的更丰富的语义信息。 MHCA模块背后的理念就是从跳跃连接中关闭不相关的或噪音区域，并凸显出感兴趣区域。下图为MHCA模块，它被设计成了一个门控注意力的形式。 三、总结 本文介绍了U-Transformer，提出使用自我和交叉注意模块来模拟远程交互和空间依赖。未来的工作可能包括研究3D模型中的U-Transformer，以及其他模式，如MRI或US图像，以及其他医学图像任务。 "},"09-PaperRead/04-TransFuse-Fusing Transformers and CNNs forMedical Image Segmentation.html":{"url":"09-PaperRead/04-TransFuse-Fusing Transformers and CNNs forMedical Image Segmentation.html","title":"TransFuse-Fusing Transformers and CNNs forMedical Image Segmentation","keywords":"","body":"TransFuse: Fusing Transformers and CNNs forMedical Image Segmentation 一、摘要 ​ 医学图像分割是开发医疗保健系统（尤其是疾病诊断和治疗计划）的必要先决条件。在各种医学图像分割任务中，U形架构（也称为U-Net）已成为事实上的标准，并取得了巨大的成功。但是，由于卷积运算的固有局部性，U-Net通常在明确建模远程依赖关系方面显示出局限性。我们提出了一种新的并行分支体系结构TransFuse来提高建模全局上下文的效率，同时保持对低级细节的有力把握。TransFuse以并行的方式将Transformer与CNN结合，可以以更浅的方式有效地捕获全局依赖性和低级空间细节。除此之外，本文还提出了一种新的融合技术BiFusion Module，以有效地融合来自两个分支的多层次特征。 二、引言 ​ 尽管CNN在医学图像分割任务中取得了巨大成功，但它在获取全局背景信息方面仍然缺乏效率。Transformer擅长建模全局上下文信息，但是在捕获细粒度细节方面存在局限性，尤其是在医学图像方面。为了结合CNN和Transformer两者的好处，有人提出了TransUnet，它利用CNN提取低级特征，然后通过Transformer模拟全局交互。过去的方式大多数都是通过用Transformer来替换卷积层，或者以顺序的方式堆叠两者，为了进一步发挥CNN加Transformer在医学图像分割中的作用，本文提出了一种不同的结构——TransFuse。它并行运行基于浅层CNN的编码器和基于Transformer的分割网络，后面接着我们提出的一个BiFusion模块，它能够将来自两个分支的特征融合在一起共同进行预测。TransFuse有以下几个特征： 可以有效地捕捉低层次的空间特征和高层次的语义语境； 它不需要很深的网络，这缓解了梯度消失和特征减少的重用问题； 它有效的减少了模型的大小并提高了推理的速度。 三、方法 如图所示，TransFuse包含两个并行的分支来分别处理不同的信息。 CNN分支：逐渐增加感受野，对从局部到全局的特征进行编码； Transformer分支：它以全局自我关注的方式启动，并在最后恢复本地详细信息。 从两个分支中提取的具有相同分辨率的特征被输入到我们提出的BiFusion中，在BiFusion模块中应用self-Attention和双线性Hadamard的乘积来选择性的融合信息。然后将多层次的特征映射进行组合，使用选通跳跃连接生成分割结果。并行分支方法有两个主要优点：首先，通过充分利用CNN和Transformers的优点，我们认为，在保持对低层上下文的敏感性的同时，传输可以捕获全局信息，而无需构建非常深的网络；其次，我们提出的BiFusion模块可以在特征提取过程中同时利用CNN和变压器的不同特性，从而使融合表示功能强大且紧凑。 CNN分支和Transformer分支不详细罗列，与其他论文中相同。 BiFusion Module： 混合特征由以下方式来实现： 通道注意力用SE块来实现，空间注意力用CBAM块来实现。 损失函数使用IOU损失和BCE损失的加权和，其中BCE损失的权重更高。 四、总结 ​ 在本文中我们提出了一种新的融合CNN和Transformer的策略，最终的体系结构TransFuse利用了CNN在建模空间相关性方面的感应偏差和Transformers在建模全局关系方面的强大能力。在参数和推理速度方面都非常高效。在未来计划i高Transformer层的效率，并在其他医疗相关任务中进行测试。 "},"09-PaperRead/05-SAUNet++- An automatic segmentation model of COVID-19 lesion fromCT slices.html":{"url":"09-PaperRead/05-SAUNet++- An automatic segmentation model of COVID-19 lesion fromCT slices.html","title":"SAUNet++- An automatic segmentation model of COVID-19 lesion fromCT slices","keywords":"","body":"SAUNet++: An automatic segmentation model of COVID-19 lesion from CT slices 一、摘要 ​ 2019年冠状病毒病（COVID-19）疫情已在世界范围内蔓延，医疗体系陷入危机。计算机断层扫描（CT）图像中COVID-19病变的精确、自动化和快速分割可帮助医生诊断并提供预后信息。然而，病变的多样性和早期病变的小区域使其分割复杂化。为了解决这些问题，我们提出了一个新的SAUNet++模型，该模型包含SER模块和ASPP模块。SER模块可以为更重要的信道分配更多的权重，缓解梯度消失的问题，ASPP模块可以使用不同的采样率通过空洞卷积获得上下文信息。此外，GDL可以降低病变大小与Dice损失之间的相关性，并被引入到解决小区域分割问题中。我们收集了来自中国、意大利和俄罗斯的多国CT扫描数据，并进行了广泛的实验。在实验中，SAUNet++ 和GDL分别与先进的分割模型和流行的损失函数进行了比较。实验结果表明，我们的方法可以有效地提高COVID-19病灶分割在Dice系数（我们的87.38%对U-NET++：86.08%），灵敏度（我们：93.28%对U-NET++：89.85%）和Hausdorff距离（我们：19.99 mm vs U-NET++：27.69mm）的准确性。 二、引言 ​ 近年来，基于深度学习的医学图像分割模型在辅助人类疾病诊断方面取得了令人满意的效果。2019冠状病毒疾病的分割仍存在以下问题。 病灶类型的多样性，病灶之间在纹理、位置、形状等特征上存在较大差异，增加了分割的难度。 2019冠状病毒疾病早期发现小面积，早期发现COVID-19患者有利于后续治疗，但早期GGO因其面积小、对比度低、外观模糊而难以识别。 2019冠状病毒疾病的数据集缺乏，这是一个挑战，收集足够的数据来训练分割模型，并且是昂贵和费时的，以获得高质量的像素级掩模。 本文的主要贡献： 在UNet++的基础上，引入了SER和ASPP模块。SER模块可以为更重要的通道分配更多的权重，并缓解梯度消失的问题，而ASPP模块可以使用不同的采样率通过空洞卷积获得上下文信息。 引入GDL来解决小区域分割问题。与常见的骰子丢失相比，它可以平衡每个区域对丢失的贡献，使训练更加稳定。 我们收集了来自四个不同数据集的多国CT扫描。实验共使用了11359张具有高质量素水平掩模的切片。 三、方法 SAUNet++体系结构如图所示，它在UNet和UNet++上进行改进，原始的UNet利用四个下采样获得高维信息，然后使用四个上采样将特征映射到原始大小，并使用四个跳跃连接合并特征映射。基于U-Net的改进方法并不总是使用四层结构，但是，下采样的组合，上采样和跳过连接保持不变。可以从不同深度的结构中提取不同的特征，这对分割都很重要，因此U-Net++将四种不同深度的结构结合起来，并使用不同长度的跳过连接。由于U-Net++使用无填充卷积，两次卷积后，同一层中的特征图的边界像素丢失，因此需要先裁剪收缩路径中的特征图，然后在展开路径中与特征图连接。为了增强U-Net++的结构，我们使用SER模块替换原来的两个卷积，并在下采样结束时添加ASPP模块。 3.1 SER SER模块如图所示，SER模块基于SE块和残差块。 3.2 ASPP ​ 卷积层和池化层的结合可以在不增加额外参数的情况下扩展图像的感受野，但池化操作会压缩图像的大小，从而丢失图像的细节。然而，上采样无法恢复所有空间信息。空洞卷积用更大的感受野覆盖图像，只有感受野中的一些像素用于卷积，这相当于在卷积核中插入孔。因此，空洞卷积可以扩展感受野，并在不丢失细节的情况下控制特征图的分辨率。 3.3 Loss Dice损失被广泛用于指导图像分割模型的训练，但在面对小区域时分割性能较差。如果图像中的像素数和背景中的像素数之间存在极端不平衡，一旦一小部分像素预测错误，就会导致Dice 损失的急剧变化，导致训练不稳定。 Abraham等人提出了focal tversky loss (FTL)来处理像素数的不平衡问题。 Sudre等人提出GDL使用与病变成反比的权重，以便更好地分割小区域： 四、总结 SAUNet++性能超过了最先进的医学图像分割模型。我们的模型也可用于分割其他肺部疾病，如普通肺炎。在未来的工作中，我们将把病变分成不同的类别来评估所提出的多类分割方法。 "},"09-PaperRead/06-Conformer-Local Features Coupling Global Representations for Visual Recognition.html":{"url":"09-PaperRead/06-Conformer-Local Features Coupling Global Representations for Visual Recognition.html","title":"Conformer-Local Features Coupling Global Representations for Visual Recognition","keywords":"","body":"Conformer: Local Features Coupling Global Representations for Visual Recognition 一、摘要 ​ 在卷积神经网络中，卷积运算擅长提取局部特征，但是难以捕获全局特征。在visual Transformer中，级联的SA模块可以捕获远程特征依赖，但是他会破坏局部特征细节。在本文中，提出了一种称为Conformer的混合网络结构，利用卷积和自注意力机制来增强表示学习。Conformer的思想来源于特征耦合单元(FCU)，它以交互式的方式融合不同分辨率下的局部特征和全局表示。Conformer采用并行结构，最大限度的保留了局部特征和全局表示。实验表明，在可比的参数复杂度下，Conformer在ImageNet上的性能比visual Transformer(DeiT-B)高出2.3%。 Code 二、引言 ​ 卷积神经网络推动了计算机视觉任务如图像分类、目标检测和实例分割等任务的进步。这很大程度上归功于卷积运算，它能以一种分层的方式收集局部特征，来表示图像。尽管CNN在局部特征提取上有优势，但在获取全局表示方面仍然存在困难，如视觉元素之间的关系，这对于高级计算机视觉任务来说是至关重要的。这里有一种最直观的解决方案就是扩大感受野，但是这就会需要更密集的池化操作，但是也会损害池化操作。 ​ 最近，Transformer结构已经被引入到可视化任务中，ViT方法通过将每个图像分割为带有位置嵌入的小块来构造一个令牌序列(token)，并应用级联Transformer来提取参数化向量作为视觉表示。由于自我注意力机制和MLP结构，visual Transformer反应了复杂的空间变换和远程依赖，构成了全局表示，但是visual transformer忽略了局部特征细节，降低了背景和前景的可分辨性。改进后的visual transformer提出了一种标记化模块或利用CNN特征图作为输入标记来捕获特征邻近信息，然而，如何精确的嵌入局部特征和全局表示的问题仍然存在。 本文的主要贡献如下： 提出了一种双网络结构，称为Conformer，它最大限度的保留了局部特征和全局表示。 提出了特征耦合单元FCU，以交互方式将卷积局部特征与基于Transformer的全局表示融合。 在可对比的参数复杂性下，Conformer的性能显著优于CNN和visual Transformer。Conformer继承了CNN和visual transformer结构的泛化优势，显示出称为通用骨干网络的巨大潜力。 三、模型相关 为了利用局部特征和全局特征，本文提出了一个并行的网络结构，如上图所示。 考虑到两种方式特征的互补性，在Conformer中，模型中连续的从transformer分支向特征图中提供全局上下文信息，以增强CNN分支的全局感知能力。同样，CNN分支的局部特征被逐步反馈到Patch Embeddings中，以丰富Transformer分支的局部细节，这样就构成了一个交互的过程。 具体实现上，Conformer由一个stem模块、双分支、桥接双分支的FCU和每个分支上的分类器（FC)组成。Stem模块是一个步长为2的7×7卷积和步长为2的3×3 max pooling，用于提取初始局部特征，然后分别送入到两个分支中。CNN分支和Transformer分支分别由N个重复卷积和Transformer块组成（具体设置如上表所示）。这种并发结构意味着CNN和Transformer分支分别可以最大限度地保留局部特征和全局表示。FCU被提出作为一个桥接模块，将CNN分支的局部特征与Transformer分支的全局表示融合。沿着这些分支结构，FCU会以交互式的方式逐步融合feature map和patch embedding。 "},"09-PaperRead/07-Dual-branch combination network-DCN.html":{"url":"09-PaperRead/07-Dual-branch combination network-DCN.html","title":"Dual-branch combination network-DCN","keywords":"","body":"Dual-branch combination network (DCN): Towards accurate diagnosis and lesion segmentation of COVID-19 using CT images 一、摘要 期刊：Medical Image Analysis —— 一区 ​ 最近，COVID-19在全球爆发和传播，在医疗资源日益紧张的情况下，开发准确和有效的诊断工具势在必行。人工智能辅助工具展现出令人满意的潜力，如，人们已经证明胸部CT图像在COVID-19的诊断和评估中能够发挥重要作用。然而，开发基于CT图像的AI诊断系统用于疾病检测面临着相当大的挑战，这主要是应为缺乏足够人工标注的样本来供模型进行训练，以及对于早期感染阶段的细微病变不够敏感。在本研究中，我们开发了一种用于COVID-19诊断的双分支组合网络(DCN)，该网络可以同时实现个体级分类和病变分割。为了将分类分支更集中于病变区域，我们开发了一种新的病变注意模块来整合中间分割结果。此外，为了管理不同成像参数对个体设备的潜在影响，提出了一种切片概率映射方法来学习从切片级到个体级分类的转换。我们在国内10 个研究机构的1202个课题的大数据集上进行了实验，结果表明： 1. 该模型在内部数据集上的分类准确率为96.74%，在外部验证数据集上的分类准确率为92.87%，优于其他模型。 2. DCN在样本较少的情况下具有相当的性能和较高的灵敏度，尤其是在针对细微病变的检测中更为明显。 3. 与其他深度学习模型相比，DCN基于高级语义信息进行分类，对感染位点具有较好的解释性。 基于我们提出的框架的COVID-19在线CT诊断平台现已可用。 二、引言 ​ 自2020年初以来，新型冠状病毒(COVID-19)在全球爆发并迅速传播。2020年3月1日，世界卫生组织(WHO)宣布该疾病位大流行疾病。根据世界卫生组织公布的实时数据，截至2020年8月8日，已有1900多万人感染了这中疾病，71.6万多名受害者死于这种疾病。毫无疑问，这一流行病已经称为对全球人口的严峻挑战。因此，准确有效的诊断该疾病是当务之急。 ​ 逆转录聚合酶链反应(RT-PCR)检测目前被认为是COVID-19诊断的金标准，但是它耗时长，假阴性率高。胸部CT图像作为一种补充在实践中对COVID-19诊断更为敏感和高效，已被广泛应用于疾病的早期筛查。以往的研究表明，可以通过CT图像评估病变的大小和严重程度，以帮助评估疾病进展和后续治疗。因此，CT在中国的“COVID-19治疗计划(试验版本7)”中被确认为COVID-19的诊断标准。然而，手工评估CT图像通常需要几个小时，考虑到众多疑似和确诊病例的效率要求，这在COVID-19临床诊断中是不可接受的。因此开发AI辅助CT诊断系统对COVID-19病例的快速诊断和准确评估至关重要。 ​ 在过去的十年中，我们见证了深度学习的出现，它已经被证明在计算机视觉和模式识别方面具有相对优势。AlexNet和VGGNet等分类模型使用一系列级联卷积模块提取特征用于图像分类。ResNet为卷积神经网络引入了shortcut，缓解了梯度消失问题。DenseNet利用每两层之间的跳跃式连接，用级联操作代替求和，使信息更容易流动。在图像分割领域，Long等人使用了完全卷积网络进行图像分割，提出了深度学习在图像分割任务中的应用。随后人们又提出了DeepLab、PSPNet、U-Net等几种深度分割网络，进一步提高了图像分割性能。其中，U-Net结构简单，易于训练，在医学图像分割中得到了广泛的应用，因此，我们在本次研究中使用了它。 ​ 到目前为止，大多数的研究都是分别进行分类和分割。事实上，这两项任务可以结合起来实现更好的性能。CT图像中的病变在COVID-19筛查中具有决定性作用，但病变的大小在疾病早期通常较小，可能被分类网络忽略。然而，来自分割网络的中间结果可能有助于通过注意力机制将分类网络更集中在病灶上，以便准确推断。此外，注意力特征图可以揭示对分类至关重要的区域，从而提高深度学习模型的可解释性，并协助临床医生进行进一步评估。因此，结合分类和分割任务可以提高性能。 ​ 在本研究中，我们提出了一个结合分割和分类的框架，同事完成COVID-19诊断和基于胸部CT图像的病灶分割。首先采用基于U-Net的肺分割方法来描绘肺轮廓。然后，采用双分支组合网络(DCN)进行片级分割和分类。我们在DCN中提出了一个病变注意力机制(Lesion Attention, LA)，利用分割和分类分支的中间结果来提高分类性能。最后采用切片概率映射策略和全连接网络(FCN)从切片结果中获得个体级结果，使该方法适用于不同切片数的CT扫描。通过与其他模型的性能比较，证明了DCN在图像分类方面的有效性。此外，我们发现该方法对小病变区域图像的分类更加敏感。这对于COVID-19的早期诊断非常有帮助，因为早期病变通常很细微，很难发现。 ​ 本文的主要贡献如下： 利用DCN同时实现了COVID-19的分割和分类，并提出了一种加权Dice损失，以确保网络的可训练性。 对COVID-19的敏感性明显提高，特别是对细微病变。 由LA模块生成的中间注意图为分类提供了可解释性。 三、模型 ​ 本文方法的总体框架可分为三部分，第一部分是基于UNet的肺分割网络，提取准确的肺区域，第二部分是提出的DCN模型，它可以利用提出的LA模块同时完成CT图像的切片级分类和分割。在第三部分中，将切片结果与切片概率映射方法相结合，利用三层全连通网络获得个体层次上的分类结果。 3.1 肺分割 ​ 对图像进行处理，消除干扰，得到感兴趣区域，及肺。使用基于HU值的阈值方法来进行胸部CT图像的预处理。这些阈值方法在实际应用中不够准确，特别是对COVID-19患者的CT图像来说。一种可能的解释是患者病灶的HU值较高，使用阈值法难以与其他器官区分，因此影响后续分析。因此我们训练了一种基于UNet的肺分割模型。 3.2 DCN ​ 本文提出了DCN来同时完成CT图像的分类和分割。该网络由分类分支和分割分支组成，分别对应于分类任务和分割任务。分类分支的主干为ResNet-50，包括4个残差块。分割分支的主干是U-Net，包括编码器和解码器。DCN接收肺分割后的图像作为输入，输出切片级分类和分割结果。 3.2.1 LA ​ 为了更好的整合两个分支的信息，提高分类性能，本文提出了LA模块。LA模块的输入包含两个部分，来自分支的Xc和来自分割分支的Xs。利用关注机制，将分类分支更多地几种在病变上。LA模块的计算公式如下： 其中Wc、Ws是表示1×1卷积层的权重，bc、bs、bint表示一个相应的偏差。f1(x)=max(x, 0)，f2(x)=1/(1+exp(-x))分别对应ReLU和Sigmoid激活函数。注意力图归一化到[0, 1]。LA模块的最终输出可以如下表示： ) f3包含一系列的单元：1×1的卷积、BN和一个ReLU激活函数。 3.3 切片概率映射 ​ DCN处理每个切片的分类，然后我们需要结合切片结果，实现个体级分类，并且确定受试者是否感染了COVID-19。然而，由于切片厚度、视野或肺体积的不同，切片数在不同的受试者中也不同。一些研究在全连接层上使用最大或平均赤化来消除这个问题。但是者可能会导致信息的丢失，因为该方法只保存所有片的最大或平均值。为了最大限度的获取每个切片信息，提出了一种基于重采样的切片概率映射策略。具体来说，我们将切片的结果按降序排序，使用双线性插值方法拟合曲线。然后我们在相同的区间内从曲线中获得100个值，并按降序获得连续概率。然后将一个简单的三层FCN应用于个体分类，并将导出的100个值作为输入。两个隐藏层的节点数分别为256和128。 3.4 损失函数 ​ 在分类分支中使用交叉熵损失函数 ​ 原始的UNet使用BCE损失函数，在我们的数据集上表现很差，COVID-19患者CT图像分割数据极不平衡，病灶区域通常比正常区域和北京小得多，BCE损失不适合这种情况。为了解决这个问题，我们使用Dice损失函数，切片级的Dice损失可以表示如下： ​ 训练分类分支需要来自正常受试者的样本。而在分割任务重，正常受试者的图像都是负样本，这样就加剧了样本的不平衡，从而影响了分支的训练，为了解决这个问题，提出一种加权的Dice损失函数用于分割分支。 ​ 将带病变和不带病变的权重设置为1和0，即只有带标注病变的切片参与分割分支的反向传播。总的损失函数表示如下： ​ 其中λ为两种损耗的权衡参数，我们在实验中设置λ为1。 四、实验和结果 ​ 本文使用内部数据集进行训练和验证，采用五折交叉验证策略，利用外部验证集评价模型的泛化性能。像素值代表-900HU到100HU窗口内的HU值，它们被进一步归一化到0到255。 ​ 该方法在内部数据集上准确率为96.74%，AUC为0.9864。在大型的外部数据集上验证了该方法的泛化性能，准确率为92.87%。实验表明，DCN模型在内部和外部数据集上都优于其他物种常用的分类模型。此外，我们还讲DCN与其他两种COVID-19分类方法进行了比较，发现DCN具有更好的新能。提出的DCN实现了99.1%的肺分割DSC和83.51%的病变分割DSC。 ​ 提出了一个LA模块，融合了分割分支和分类分支的中间结果，以提高性能。将两个分支的中间结果连接起来，生成用于图像分类的注意力图，这样，分类分支就可以更多的几种在感染点位上。进行了一些消融研究，证明了LA块的有效性。显著提高了准确率。 ​ 后续工作为将DCN扩展到更广泛的应用领域，如肺结节分类和肿瘤检测。 "},"10-Others/":{"url":"10-Others/","title":"Others","keywords":"","body":""},"10-Others/01-位运算.html":{"url":"10-Others/01-位运算.html","title":"位运算","keywords":"","body":"位运算 一、位运算操作 按位与运算：两位都是1的时候结果才为1，否则为0 1 0 0 1 1 & 1 1 0 0 1 ---------------- 1 0 0 0 1 按位或运算：两位都是0，结果才为0，否则为1 1 0 0 1 1 | 1 1 0 0 1 ---------------- 1 1 0 1 1 按位异或运算：两位相同则为0，不同则为1 1 0 0 1 1 ^ 1 1 0 0 1 ---------------- 0 1 0 1 0 按位取反运算：0变1，1变0 ~ 1 0 0 1 1 ---------------- 0 1 1 0 0 左移运算：向左进行移位操作，高位丢弃，低位补0 a = 12 b = 2 a的二进制表示为 1100 a 右移运算：右移操作分为算术右移和逻辑右移，算术右移是带符号的右移，逻辑右移是不带符号的右移。算术右移：将每一位向右移位，左边不足的位补符号位的数，低位丢弃。逻辑右移：向右进行移位操作，高位补0，低位丢弃。 "}}